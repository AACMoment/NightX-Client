package net.aspw.nightx.features.module.modules.exploit;

import net.aspw.nightx.event.EventTarget;
import net.aspw.nightx.event.PacketEvent;
import net.aspw.nightx.event.UpdateEvent;
import net.aspw.nightx.features.module.Module;
import net.aspw.nightx.features.module.ModuleCategory;
import net.aspw.nightx.features.module.ModuleInfo;
import net.aspw.nightx.utils.timer.TimeUtils;
import net.aspw.nightx.value.IntegerValue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C16PacketClientStatus;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

@ModuleInfo(name = "Bypass", spacedName = "Bypass", category = ModuleCategory.EXPLOIT)
public class Bypass extends Module {

    private final HashMap<Packet<?>, Long> packetsMap = new HashMap<>();

    @Override
    public void onDisable() {
        packetsMap.clear();
    }    private final IntegerValue maxDelayValue = new IntegerValue("MaxDelay", 250, 0, 5000, "ms") {
        @Override
        protected void onChanged(final Integer oldValue, final Integer newValue) {
            final int minDelayValue = Bypass.this.minDelayValue.get();

            if (minDelayValue > newValue)
                set(minDelayValue);
        }
    };

    @EventTarget
    public void onPacket(final PacketEvent event) {
        final Packet packet = event.getPacket();

        if ((packet instanceof C00PacketKeepAlive || packet instanceof C16PacketClientStatus) && !(mc.thePlayer.isDead || mc.thePlayer.getHealth() <= 0) && !packetsMap.containsKey(packet)) {
            event.cancelEvent();

            synchronized (packetsMap) {
                packetsMap.put(packet, System.currentTimeMillis() + TimeUtils.randomDelay(minDelayValue.get(), maxDelayValue.get()));
            }
        }
    }

    @EventTarget(ignoreCondition = true)
    public void onUpdate(final UpdateEvent event) {
        try {
            synchronized (packetsMap) {
                for (final Iterator<Map.Entry<Packet<?>, Long>> iterator = packetsMap.entrySet().iterator(); iterator.hasNext(); ) {
                    final Map.Entry<Packet<?>, Long> entry = iterator.next();

                    if (entry.getValue() < System.currentTimeMillis()) {
                        mc.getNetHandler().addToSendQueue(entry.getKey());
                        iterator.remove();
                    }
                }
            }
        } catch (final Throwable t) {
            t.printStackTrace();
        }
    }    private final IntegerValue minDelayValue = new IntegerValue("MinDelay", 200, 0, 5000, "ms") {

        @Override
        protected void onChanged(final Integer oldValue, final Integer newValue) {
            final int maxDelayValue = Bypass.this.maxDelayValue.get();

            if (maxDelayValue < newValue)
                set(maxDelayValue);
        }
    };






}
